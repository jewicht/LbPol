/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooLegendre2Pdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include "legendre2f2.h"

ClassImp(RooLegendre2Pdf) 

RooLegendre2Pdf::RooLegendre2Pdf(const char *name, const char *title, 
				     RooAbsReal& _phi1,
				     RooAbsReal& _phi2,
				     RooArgList& _varlist) :
  RooAbsPdf(name,title), 
  phi1("phi1","phi1",this,_phi1),
  phi2("phi2","phi2",this,_phi2),
  varlist("varlist","varlist",this)
{ 
  
  TIterator* coefIter = _varlist.createIterator() ;
  RooAbsArg* coef ;
  
  while((coef = (RooAbsArg*)coefIter->Next())) {
    if (!dynamic_cast<RooAbsReal*>(coef)) {
      std::cout << "RooLegendre2Pdf::ctor(" << GetName() << ") ERROR: coefficient " << coef->GetName() 
		<< " is not of type RooAbsReal" << std::endl ;
      assert(0) ;
    }
    varlist.add(*coef) ;
  }
  delete coefIter ;
  
  
  const int varlen=strlen(varlist[0].GetName());
  
  for (int i=0;i<varlist.getSize();i++) {
    
    const char* buf=varlist[i].GetName();
    const int len=strlen(buf);
    const int vari=10*chtoint(buf[len-4])+chtoint(buf[len-3]);
    const int varj=10*chtoint(buf[len-2])+chtoint(buf[len-1]);
    //    const int vark=10*chtoint(buf[len-2])+chtoint(buf[len-1]);
    
    if (len!=varlen or 
	vari<0 or vari>=ordermax2i or
	varj<0 or varj>=ordermax2j)  assert(i);
  }
} 


RooLegendre2Pdf::RooLegendre2Pdf(const RooLegendre2Pdf& other, const char* name) :  
  RooAbsPdf(other,name), 
  phi1("phi1",this,other.phi1),
  phi2("phi2",this,other.phi2),
  varlist("varlist",this,other.varlist)
{ 
} 



Double_t RooLegendre2Pdf::evaluate() const 
{ 
  // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
  

  double coeff2[ordermax2i][ordermax2j];
  memset(coeff2,0,ordermax2i*ordermax2j*sizeof(double));
  
  const Int_t len=strlen(varlist[0].GetName());
  for (int i=0;i<varlist.getSize();i++) {
    const char* buf=varlist[i].GetName();
    const int vari=10*chtoint(buf[len-4])+chtoint(buf[len-3]);
    const int varj=10*chtoint(buf[len-2])+chtoint(buf[len-1]);
    //    const int vark=10*chtoint(buf[len-2])+chtoint(buf[len-1]);

    //    std::cout << varlist[i].GetName() << " " << vari << " " << varj << std::endl;
    coeff2[vari][varj]=((RooAbsReal&)varlist[i]).getVal(); 
  }
  
  const double value=pdfval(phi1,phi2,coeff2) ; 
  //  if (phi1<-0.999 and phi2>0.999 and costheta2<-0.999) std::cerr << value << std::endl;
  
  return value;
  //  return (value>0.)?value:0.;
} 



Int_t RooLegendre2Pdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
{ 
  // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
  // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
  // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
  // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
  // EXPRESSION MULTIPLE TIMES
  
  //  return 0;

  // if (matchArgs(allVars,analVars,x)) return 1 ;    
  if ( matchArgs(allVars,analVars, RooArgSet(phi1.arg(),phi2.arg()) ) ) return 1;
  if ( matchArgs(allVars,analVars, RooArgSet(phi2.arg()) ) ) return 2;
  if ( matchArgs(allVars,analVars, RooArgSet(phi1.arg()) ) ) return 3;
  // if ( matchArgs(allVars,analVars, RooArgSet(phi1.arg(),phi2.arg()) ) ) return 4;
  
  return 0;
} 



Double_t RooLegendre2Pdf::analyticalIntegral(Int_t code, const char* rangeName) const  
{ 
  // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
  // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
  // BOUNDARIES FOR EACH OBSERVABLE x

  // assert(code==1) ; 
  // return (x.max(rangeName)-x.min(rangeName)) ; 
  
  double coeff2[ordermax2i][ordermax2j];
  memset(coeff2,0,ordermax2i*ordermax2j*sizeof(double));
  
  const Int_t len=strlen(varlist[0].GetName());
  for (int i=0;i<varlist.getSize();i++) {
    const char* buf=varlist[i].GetName();
    const int vari=10*chtoint(buf[len-4])+chtoint(buf[len-3]);
    const int varj=10*chtoint(buf[len-2])+chtoint(buf[len-1]);
    coeff2[vari][varj]=((RooAbsReal&)varlist[i]).getVal(); 
  }

  Double_t val[2][2];
  memset(val, 0, 2*2*sizeof(Double_t));
  val[0][0]=phi1.min(rangeName);
  val[0][1]=phi1.max(rangeName);
  val[1][0]=phi2.min(rangeName);
  val[1][1]=phi2.max(rangeName);
  // val[2][0]=costheta2.min(rangeName);
  // val[2][1]=costheta2.max(rangeName);
  
  Double_t result=0.;
  switch(code) {
  case 1: 
    for (int a=0; a<=1; a++) {
      for (int b=0; b<=1; b++) {
	result+= pow(-1., a+b) * primitiveval(val[0][a],val[1][b],coeff2);
      }
    }
    return result;
    break;
  case 2://for phi1
    for (int a=0; a<=1; a++) {
      result+=pow(-1., a+1) * primitivedphi1val(phi1,val[1][a],coeff2);
    }
    return result;
    break;
    
  case 3://for phi2
    for (int a=0; a<=1; a++) {
      result+=pow(-1., a+1) * primitivedphi2val(val[0][a],phi2,coeff2);
    }
    return result;
    break;
    
  // case 4://for costheta2
  //   for (int a=0; a<=1; a++) {
  //     for (int b=0; b<=1; b++) {
  // 	result+=pow(-1., a+b) * primitivedcostheta2val(val[0][a],val[1][b],costheta2,coeff3);
  //     }
  //   }
  //   return result;
  //   break;
    
  }

  return 0 ; 
} 



