/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooLegendre5Pdfv2.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include "legendre5f5.h"

ClassImp(RooLegendre5Pdfv2) 

RooLegendre5Pdfv2::RooLegendre5Pdfv2(const char *name, const char *title, 
				     RooAbsReal& _costheta0,
				     RooAbsReal& _costheta1,
				     RooAbsReal& _costheta2,
				     RooAbsReal& _phi1,
				     RooAbsReal& _phi2,
				     RooArgList& _varlist
				     ) :
  RooAbsPdf(name,title), 
  costheta0("costheta0","costheta0",this,_costheta0),
  costheta1("costheta1","costheta1",this,_costheta1),
  costheta2("costheta2","costheta2",this,_costheta2),
  phi1("phi1","phi1",this,_phi1),
  phi2("phi2","phi2",this,_phi2),
  varlist("varlist","varlist",this)
{ 
  TIterator* coefIter = _varlist.createIterator() ;
  RooAbsArg* coef ;
  while((coef = (RooAbsArg*)coefIter->Next())) {
    if (!dynamic_cast<RooAbsReal*>(coef)) {
      std::cout << "RooLegendre5Pdfv2::ctor(" << GetName() << ") ERROR: coefficient " << coef->GetName() 
		<< " is not of type RooAbsReal" << std::endl ;
      assert(0) ;
    }
    varlist.add(*coef) ;
  }
  delete coefIter ;
  
  const int varlen=strlen(varlist[0].GetName());
  for (int i=0;i<varlist.getSize();i++) {
    const char* buf=varlist[i].GetName();
    const int len=strlen(buf);
    const int vari=chtoint(buf[len-5]);
    const int varj=chtoint(buf[len-4]);
    const int vark=chtoint(buf[len-3]);
    const int varl=chtoint(buf[len-2]);
    const int varm=chtoint(buf[len-1]);

     if (len!=varlen or 
	 vari<0 or vari>=ordermax5i or
	 varj<0 or varj>=ordermax5j or
	 vark<0 or vark>=ordermax5k or
	 varl<0 or varl>=ordermax5l or
	 varm<0 or varm>=ordermax5m) assert(i);
  }
} 


RooLegendre5Pdfv2::RooLegendre5Pdfv2(const RooLegendre5Pdfv2& other, const char* name) :  
  RooAbsPdf(other,name), 
  costheta0("costheta0",this,other.costheta0),
  costheta1("costheta1",this,other.costheta1),
  costheta2("costheta2",this,other.costheta2),
  phi1("phi1",this,other.phi1),
  phi2("phi2",this,other.phi2),
  varlist("varlist",this,other.varlist)
{ 
} 



Double_t RooLegendre5Pdfv2::evaluate() const 
{ 
  // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
  
  double coeff5[ordermax5i][ordermax5j][ordermax5k][ordermax5l][ordermax5m];
  memset(coeff5,0,ordermax5i*ordermax5j*ordermax5k*ordermax5l*ordermax5m*sizeof(double));
  
  const int len=strlen(varlist[0].GetName());
  for (int i=0;i<varlist.getSize();i++) {
    const char* buf=varlist[i].GetName();
    coeff5[chtoint(buf[len-5])][chtoint(buf[len-4])][chtoint(buf[len-3])][chtoint(buf[len-2])][chtoint(buf[len-1])]=((RooAbsReal&)varlist[i]).getVal(); 
  }
  
  return pdfval5f5(costheta0,costheta1,costheta2,phi1,phi2,coeff5); 
} 



Int_t RooLegendre5Pdfv2::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
{ 
  // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
  // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
  // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
  // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
  // EXPRESSION MULTIPLE TIMES
  
  // if (matchArgs(allVars,analVars,x)) return 1 ; 
  
  //5
  if ( matchArgs(allVars,analVars, RooArgSet(costheta0.arg(),costheta1.arg(),costheta2.arg(),phi1.arg(),phi2.arg()) ) ) return 1;
  
  //4
  if ( matchArgs(allVars,analVars, RooArgSet(costheta1.arg(),costheta2.arg(),phi1.arg(),phi2.arg()) ) ) return 2;
  if ( matchArgs(allVars,analVars, RooArgSet(costheta0.arg(),costheta2.arg(),phi1.arg(),phi2.arg()) ) ) return 3;
  if ( matchArgs(allVars,analVars, RooArgSet(costheta0.arg(),costheta1.arg(),phi1.arg(),phi2.arg()) ) ) return 4;
  if ( matchArgs(allVars,analVars, RooArgSet(costheta0.arg(),costheta1.arg(),costheta2.arg(),phi2.arg()) ) ) return 5;
  if ( matchArgs(allVars,analVars, RooArgSet(costheta0.arg(),costheta1.arg(),costheta2.arg(),phi1.arg()) ) ) return 6;
  
  return 0 ; 
} 



Double_t RooLegendre5Pdfv2::analyticalIntegral(Int_t code, const char* rangeName) const  
{ 
  // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
  // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
  // BOUNDARIES FOR EACH OBSERVABLE x
  
  // assert(code==1) ; 
  // return (x.max(rangeName)-x.min(rangeName)) ; 
  
  double coeff5[ordermax5i][ordermax5j][ordermax5k][ordermax5l][ordermax5m];
  memset(coeff5,0,ordermax5i*ordermax5j*ordermax5k*ordermax5l*ordermax5m*sizeof(double));
  
  const int len=strlen(varlist[0].GetName());
  for (int i=0;i<varlist.getSize();i++) {
    const char* buf=varlist[i].GetName();
    coeff5[chtoint(buf[len-5])][chtoint(buf[len-4])][chtoint(buf[len-3])][chtoint(buf[len-2])][chtoint(buf[len-1])]=((RooAbsReal&)varlist[i]).getVal(); 
  }
  
  
  Double_t val[5][2];
  Double_t result=0.;
  val[0][0]=costheta0.min(rangeName);
  val[0][1]=costheta0.max(rangeName);
  val[1][0]=costheta1.min(rangeName);
  val[1][1]=costheta1.max(rangeName);
  val[2][0]=costheta2.min(rangeName);
  val[2][1]=costheta2.max(rangeName);
  val[3][0]=phi1.min(rangeName);
  val[3][1]=phi1.max(rangeName);
  val[4][0]=phi2.min(rangeName);
  val[4][1]=phi2.max(rangeName);
    
  
  switch(code) {
  case 1: 
    for (int a=0; a<=1; a++) {
      for (int b=0; b<=1; b++) {
	for (int c=0; c<=1; c++) {
	  for (int d=0; d<=1; d++) {
	    for (int e=0; e<=1; e++) {
	      result+=pow(-1., a+b+c+d+e+1) * primitiveval5f5(val[0][a],val[1][b],val[2][c],val[3][d],val[4][e],coeff5);
	    }
	  }
	}
      }
    }
    
    return result;
    break;
    
  case 2://for costheta0
    for (int a=0; a<=1; a++) {
      for (int b=0; b<=1; b++) {
	for (int c=0; c<=1; c++) {
	  for (int d=0; d<=1; d++) {
	    result+=pow(-1., a+b+c+d) * primitivedcostheta0val5f5(costheta0,val[1][a],val[2][b],val[3][c],val[4][d],coeff5);
	  }
	}
      }
    }
    return result;
    break;
    
  case 3://for costheta1
    for (int a=0; a<=1; a++) {
      for (int b=0; b<=1; b++) {
	for (int c=0; c<=1; c++) {
	  for (int d=0; d<=1; d++) {
	    result+=pow(-1., a+b+c+d) * primitivedcostheta1val5f5(val[0][a],costheta1,val[2][b],val[3][c],val[4][d],coeff5);
	  }
	}
      }
    }
    return result;
    break;
    
  case 4://for costheta2
    for (int a=0; a<=1; a++) {
      for (int b=0; b<=1; b++) {
	for (int c=0; c<=1; c++) {
	  for (int d=0; d<=1; d++) {
	    result+=pow(-1., a+b+c+d) * primitivedcostheta2val5f5(val[0][a],val[1][b],costheta2,val[3][c],val[4][d],coeff5);
	  }
	}
      }
    }
    return result;
    break;
    

    
    
  case 5://for phi1
    for (int a=0; a<=1; a++) {
      for (int b=0; b<=1; b++) {
	for (int c=0; c<=1; c++) {
	  for (int d=0; d<=1; d++) {
	    result+=pow(-1., a+b+c+d) * primitivedphi1val5f5(val[0][a],val[1][b],val[2][c],phi1,val[4][d],coeff5);
	  }
	}
      }
    }
    return result;
    break;
    
    
  case 6://for phi2
    for (int a=0; a<=1; a++) {
      for (int b=0; b<=1; b++) {
	for (int c=0; c<=1; c++) {
	  for (int d=0; d<=1; d++) {
	    result+=pow(-1., a+b+c+d) * primitivedphi2val5f5(val[0][a],val[1][b],val[2][c],val[3][d],phi2,coeff5);
	  }
	}
      }
    }
    return result;
    break;
    
  }
  
  return 0 ; 
  
} 



